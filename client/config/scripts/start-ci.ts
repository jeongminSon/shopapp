// Do this as the first thing so that any code reading it knows the right env.
process.env.BABEL_ENV = 'development'
process.env.NODE_ENV = 'development'

// Makes the script crash on unhandled rejections instead of silently
// ignoring them. In the future, promise rejections that are not handled will
// terminate the Node.js process with a non-zero exit code.
process.on('unhandledRejection', err => {
  throw err
})

// Ensure environment variables are read.
require('../env')

import * as chalk from 'chalk'
import * as fs from 'fs'
import * as path from 'path'
import * as webpack from 'webpack'
import * as express from 'express'
import * as createWebpackDevMiddleware from 'webpack-dev-middleware'
import * as createWebpackHotMiddleware from 'webpack-hot-middleware'

import { Paths } from '../paths'

const { spawn } = require('child_process')
const clearConsole = require('react-dev-utils/clearConsole')
const checkRequiredFiles = require('react-dev-utils/checkRequiredFiles')
const { choosePort, createCompiler, prepareProxy, prepareUrls } = require('react-dev-utils/WebpackDevServerUtils')
const openBrowser = require('react-dev-utils/openBrowser')
const history = require('connect-history-api-fallback')

export interface StartConfiguration {
  paths: Paths
  webpackClientConfig: any
  clientPort: number
  serverPort: number
  host: string
  protocol: string
}

export default async function start(config: StartConfiguration) {
  const paths = config.paths
  const isInteractive = process.stdout.isTTY

  // Warn and crash if required files are missing
  if (!checkRequiredFiles([paths.clientEntry])) {
    process.exit(1)
  }

  // Tools like Cloud9 rely on this.
  const DEFAULT_CLIENT_PORT = parseInt(process.env.PORT, 10) || config.clientPort
  // const DEFAULT_SERVER_PORT = parseInt(process.env.PORT, 10) || config.serverPort
  const HOST = process.env.HOST || config.host || '0.0.0.0'

  // We attempt to use the default port but if it is busy, we offer the user to
  // run on a different port. `detect()` Promise resolves to the next free port.
  const clientPort = DEFAULT_CLIENT_PORT
  const serverPort = config.serverPort

  // Client Side

  const protocol = process.env.HTTPS === 'true' ? 'https' : 'http'
  const appName = require(paths.packageJson).name
  const urls = prepareUrls(protocol, HOST, clientPort)

  // We do this before importing the wepack.config.client.dev otherwise
  // REACT_APP_CLIENT_PORT won't be set at new webpack.DefinePlugin(env.stringified)
  process.env.REACT_APP_CLIENT_PORT = String(clientPort)
  const configWebpackClient = config.webpackClientConfig

  // Create a webpack compiler that is configured with custom messages.
  // we use different compiler
  // const compiler = createCompiler(webpack, configWebpackClient, appName, urls, useYarn)
  const clientCompiler = webpack(configWebpackClient)

  // Load proxy config
  // const proxySetting = require(paths.packageJson).proxy
  // const proxyConfig = prepareProxy(proxySetting, paths.public)
  // const createDevServerConfig = config.webpackDevServerConfig
  // Serve webpack assets generated by the compiler over a web sever.

  let clientCompiling = false

  clientCompiler.plugin('compile', () => {
    clientCompiling = true
  })

  clientCompiler.plugin('done', stats => {
    if (stats.hasErrors()) {
    } else {
      clientCompiling = false
    }
  })

  const clientApp = express()
  const webpackDevMiddleware = createWebpackDevMiddleware(clientCompiler, {
    headers: { 'Access-Control-Allow-Origin': `http://${HOST}:${serverPort}` },
    publicPath: configWebpackClient.output.publicPath,
  })

  clientApp.use(history())
  clientApp.use(webpackDevMiddleware)
  clientApp.use(createWebpackHotMiddleware(clientCompiler))

  const clientServer = clientApp.listen(clientPort, err => {
    if (err) {
      return console.log(err)
    }
    if (isInteractive) {
      clearConsole()
    }
  })

  const signals = ['SIGINT', 'SIGTERM']
  signals.forEach(sig => {
    process.on(sig as any, async () => {
      webpackDevMiddleware.close()
      await clientServer.close()
      process.exit()
    })
  })
}
